
ORG 100H

JMP START
    
    SCORE                       DW 0
    TO_CLEAR                    DB 0    
    
    MSG_QUIT_GAME               DB " Press Q to quit$"
    MSG_GAMEOVER                DB " GAMEOVER!$"
    MSG_SCORE                   DB " 000$" 
    MSG_SCORE_TEXT              DB " Score:$"
    MSG_AUTHOR                  DB " By Mohammad Hashemi, 2021$"
    MSG_LEFT_KEY                DB " Left: A$"
    MSG_RIGHT_KEY               DB " Right: D$"
    MSG_ROTATE_KEY              DB " Rotate: W$"
    MSG_STALL_KEY               DB " Stall: F$"
    MSG_DOWN_KEY                DB " Down: S$"
    MSG_EXIT_KEY                DB " Exit: Esc$"
    MSG_TETRIS                  DB " -TETRIS$"
    
    VIDEO_MEM                   DW 0A000H           ; START OF VIDEO MEMORY
    PIXEL_PER_BLOCK             DW 4
    WINDOW_WIDTH                DW 320
    WINDOW_HEIGHT               DW 200
    GAME_OVER                   DB ?
    
    ACTIVE                      DB 8 DUP (?)
    NEXT                        DB 8 DUP (?)
    PREDICT                     DB 8 DUP (?)
    PIECES                      DB 5,4,6,4,7,4,8,4, 5,4,6,4,5,5,6,5, 5,4,5,5,5,6,6,6, 5,4,5,5,6,5,6,6, 5,4,6,4,6,5,7,4 
    PIECE_COLOR                 DB 3, 0EH, 6, 2, 5
    ACTIVE_PIECE_COLOR          DB ?
    PREDICTION_PIECE_COLOR      DB 7H    ; LIGHT GRAY
    AXISX                       DB 1
    AXISY                       DB 1
    
    TICKHI                      DW ?
    TICKLO                      DW ?
    
    GRID_LEFT_OFFSET            DW 130
    GRID_TOP_OFFSET             DW 40
    GRID_WIDTH_SIZE             DW 16               ; GRID WIDTH  (BLOCKS)
    GRID_HEIGHT_SIZE            DW 32               ; GRID HEIGHT (BLOCKS)
    GRID_BACKGROUND_COLOR       DB 0
    GRID_NON_BACKGROUND_COLOR   DB 2
    GRID_BORDER_COLOR           DB 1
    GRID                        DB 512 DUP (1)        ; GRID (MUST BE GRIDH_HEIGHT * GRID_WIDTH)


;=====================================    
START:
    MOV AH, 00
    MOV AL, 19
    INT 10H
    
PRINT_STRINGS_ON_THE_SCREEN:

    MOV DH, 23 ; ROW
    MOV DL, 7  ; COLUMN
    MOV BX, OFFSET MSG_AUTHOR
    CALL PRINT_STRING_AT
    
    MOV DH, 3
    MOV DL, 16
    MOV BX, OFFSET MSG_TETRIS
    CALL PRINT_STRING_AT
    
    MOV DH, 5
    MOV DL, 2
    MOV BX, OFFSET MSG_LEFT_KEY
    CALL PRINT_STRING_AT
    
    MOV DH, 8
    MOV DL, 2
    MOV BX, OFFSET MSG_RIGHT_KEY
    CALL PRINT_STRING_AT
    
    MOV DH, 11
    MOV DL, 2
    MOV BX, OFFSET MSG_DOWN_KEY
    CALL PRINT_STRING_AT
    
    MOV DH, 14
    MOV DL, 2
    MOV BX, OFFSET MSG_ROTATE_KEY
    CALL PRINT_STRING_AT
    
    MOV DH, 17
    MOV DL, 2
    MOV BX, OFFSET MSG_STALL_KEY
    CALL PRINT_STRING_AT
    
    MOV DH, 20
    MOV DL, 2
    MOV BX, OFFSET MSG_EXIT_KEY
    CALL PRINT_STRING_AT
    
    MOV DH, 17
    MOV DL, 26
    MOV BX, OFFSET MSG_SCORE_TEXT
    CALL PRINT_STRING_AT
    
    MOV DH, 17
    MOV DL, 33
    MOV BX, OFFSET MSG_SCORE
    CALL PRINT_STRING_AT
    
    #start=LED_Display.exe#
    #MAKE_COM#
    NAME "TETRIS"
    CALL DISPLAY_SCORE_ON_LED
    
    
    MOV CX, 512
    MOV BX, OFFSET GRID
INIT_LOOP:
    CMP CX, 17
    JB  INIT_BORDER_LOOP    ; TOP BORDER
    CMP CX, 496
    JA  INIT_BORDER_LOOP    ; BOTTOM BORDER
    MOV DX, CX
    SHR DX, 4
    SHL DX, 4
    CMP DX, CX
    JE  INIT_BORDER_LOOP    ; LEFT BORDER
    MOV DX, CX
    DEC DX
    SHR DX, 4
    SHL DX, 4
    INC DX
    CMP DX, CX
    JE  INIT_BORDER_LOOP    ; RIGHT BORDER
    MOV AL, GRID_BACKGROUND_COLOR
    MOV [BX], AL
    JMP INIT_END
INIT_BORDER_LOOP:
    MOV AL, GRID_BORDER_COLOR
    MOV [BX], AL
INIT_END:
    INC BX
    LOOP INIT_LOOP 
      
    
    
    ; INIT TIMER
    MOV AH, 0
    INT 1AH
    MOV TICKHI, CX
    MOV TICKLO, DX
    MOV GAME_OVER, 0
    
    CALL GENERATE_NEW_PIECE
    CALL DRAW_GRID
    CALL DRAW_CURRENT_PIECE
    
MAIN:
    CALL CHECK_TIME
    CMP AL, 1
    JE NO_TICK
    CALL MOVE_DOWN                     
    CMP GAME_OVER, 1        ; GAME OVER!!
        
    JE GAMEOVER
    CALL DRAW_GRID
    CALL DRAW_CURRENT_PIECE

NO_TICK:
    MOV AH, 1
    INT 16H
    JZ MAIN
    
    CMP AL, 27  ; ESC
    JE GAMEOVER
    CMP AL, "a"
    JE  LEFT_KEY
    CMP AL, "s"
    JE  DOWN_KEY
    CMP AL, "d"
    JE  RIGHT_KEY
    CMP AL, "w"
    JE  ROTATE_KEY
    CMP AL, "f"
    JE  STALL_KEY
    
    MOV AH, 0
    INT 16H
    JMP MAIN
    
LEFT_KEY:
    CALL MOVE_LEFT
    MOV AH, 0
    INT 16H
    CALL DRAW_GRID
    CALL DRAW_CURRENT_PIECE

    JMP MAIN
RIGHT_KEY:
    CALL MOVE_RIGHT
    MOV AH, 0
    INT 16H
    CALL DRAW_GRID
    CALL DRAW_CURRENT_PIECE

    JMP MAIN
DOWN_KEY:
    CALL MOVE_DOWN
    CMP GAME_OVER, 1
    JE GAMEOVER
    MOV AH, 0
    INT 16H
    CALL DRAW_GRID
    CALL DRAW_CURRENT_PIECE

    JMP MAIN
ROTATE_KEY:
    CALL ROTATE
    CMP GAME_OVER, 1
    JE GAMEOVER
    MOV AH, 0
    INT 16H
    CALL DRAW_GRID
    CALL DRAW_CURRENT_PIECE

    
    JMP MAIN
STALL_KEY:
    CALL STALL
    CMP GAME_OVER, 1
    JE GAMEOVER
    MOV AH, 0
    INT 16H
    CALL DRAW_GRID
    CALL DRAW_CURRENT_PIECE

    JMP MAIN
    
GAMEOVER:
    ; CLEAR SCREEN
    MOV AH, 06H
    MOV AL, 00H
    MOV BH, 00H
    MOV CX, 0000H
    MOV DX, 184FH
    INT 10H
    
    MOV DH, 15
    MOV DL, 15
    MOV BX, OFFSET MSG_SCORE_TEXT
    CALL PRINT_STRING_AT
    
    MOV DH, 15
    MOV DL, 22
    MOV BX, OFFSET MSG_SCORE
    CALL PRINT_STRING_AT
    
    MOV DH, 22
    MOV DL, 12
    MOV BX, OFFSET MSG_QUIT_GAME
    CALL PRINT_STRING_AT
    
    MOV DH, 8
    MOV DL, 15
    MOV BX, OFFSET MSG_GAMEOVER
    CALL PRINT_STRING_AT
    
    
WAIT:
            
    MOV AH, 00
    INT 16H    
    CMP AL, "q"   ; QUIT
    JE END_GAME
    JMP WAIT
        
END_GAME:

    
    
    MOV AH, 0
    MOV AL, 3
    INT 10H    
    POP DX
    POP CX
    POP BX
    POP AX
                
    MOV AH, 4CH
    MOV AL, 00
    INT 21H
;=====================================
;
; PAINT A SQUARE
;
; AL = COLOR
; DX = ROW INDEX
; BX = COLUMN INDEX
;
; ====================================
DRAW_SQUARE PROC
    PUSH AX
    PUSH CX
    PUSH ES
    PUSH DI
    
    MOV ES, VIDEO_MEM
    MOV DI, 0
    MOV CX, DX
LOOP1:
    ADD DI, WINDOW_WIDTH
    LOOP LOOP1
    
    ADD DI, BX     ; DI = DX * 320 + BX
    MOV CX, PIXEL_PER_BLOCK
LOOP2:
    PUSH CX
    MOV CX, PIXEL_PER_BLOCK
    
LOOP3:
    MOV ES:[DI], AL
    INC DI
    LOOP LOOP3
    
    POP CX
    ADD DI, WINDOW_WIDTH
    SUB DI, PIXEL_PER_BLOCK
    LOOP LOOP2
    
             
    POP  DI
    POP  ES
    POP  CX
    POP  AX
    
    
    RET
DRAW_SQUARE ENDP    

DRAW_GRID PROC
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    
    MOV AL, GRID_BACKGROUND_COLOR
    MOV CX, 512
    MOV BX, 0
    MOV DX, 0
    
DRAW_GRID_EACH_INDEX:
    PUSH BX   
    MOV BX, 512
    SUB BX, CX
    MOV AL, GRID[BX]
    POP BX
    PUSH BX
    PUSH DX
    ADD BX, GRID_LEFT_OFFSET
    ADD DX, GRID_TOP_OFFSET
    CALL DRAW_SQUARE
    POP DX
    POP BX
    ADD BX, PIXEL_PER_BLOCK
    CMP BX, 64
    JNE DRAW_GRID_NO_SHIFT
    MOV BX, 0                 ; FIRST COLUMN
    ADD DX, PIXEL_PER_BLOCK   ; NEXT LINE
DRAW_GRID_NO_SHIFT:
    LOOP DRAW_GRID_EACH_INDEX    
      
     
    
    POP DX
    POP CX
    POP BX
    POP AX
    
    RET
ENDP DRAW_GRID




GENERATE_NEW_PIECE PROC
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	MOV AH, 0
	INT 1AH     ; SYSTEM CLOCK INTERRUPT
	MOV AX, DX
	MOV AH, 0
	MOV BL, 5    ; BL = NUMBER OF DIFFERENT TYPES OF PIECES
	DIV BL
	MOV AL, AH	
	MOV AH,0
	MOV BX, OFFSET PIECE_COLOR
	ADD BX, AX 
	MOV DX, [BX]
	MOV ACTIVE_PIECE_COLOR, DX 
	SHL AX, 3
	
	MOV BX, OFFSET PIECES
	       
	ADD BX, AX
	MOV CX, 8
	

NEW_PIECE_EACH_BLOCK:
	MOV AL,[BX]
	PUSH BX
	MOV BX, 8
	SUB BX, CX
	MOV ACTIVE[BX], AL
	POP BX
	INC BX                                          
	LOOP NEW_PIECE_EACH_BLOCK
	
	MOV AXISX, 5
	MOV AXISY, 4
	
	POP DX
	POP CX
	POP BX
	POP AX	
	RET
GENERATE_NEW_PIECE ENDP

DRAW_CURRENT_PIECE PROC
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	MOV AL, ACTIVE_PIECE_COLOR
	MOV CX, 8
DRAW_CURRENT_PIECE_EACH_BLOCK:
	MOV BX, CX
	DEC BX
	MOV DL, ACTIVE[BX]
	MOV DH, 0
	DEC CX
	DEC BX
	MOV BL, ACTIVE[BX]
	MOV BH, 0
	SHL BX, 2
	ADD BX, GRID_LEFT_OFFSET
	SHL DX, 2
	ADD DX, GRID_TOP_OFFSET
	CALL DRAW_SQUARE	
	LOOP DRAW_CURRENT_PIECE_EACH_BLOCK
	
	POP DX
	POP CX
	POP BX
	POP AX
	RET
DRAW_CURRENT_PIECE ENDP

DRAW_PREDICTION_PIECE PROC
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	MOV AL, 7H
	MOV CX, 8
DRAW_PREDICTION_PIECE_EACH_BLOCK:
	MOV BX, CX
	DEC BX
	MOV DL, PREDICT[BX]
	MOV DH, 0
	DEC CX
	DEC BX
	MOV BL, PREDICT[BX]
	MOV BH, 0
	SHL BX, 2
	ADD BX, GRID_LEFT_OFFSET
	SHL DX, 2
	ADD DX, GRID_TOP_OFFSET
	CALL DRAW_SQUARE	
	LOOP DRAW_PREDICTION_PIECE_EACH_BLOCK
	
	POP DX
	POP CX
	POP BX
	POP AX
	RET
DRAW_PREDICTION_PIECE ENDP



MOVE_LEFT PROC
    PUSH AX
    PUSH CX
    PUSH DX
    
    CALL VALIDATE_LEFT_MOVE
    CMP AL, 0
    JNE DONT_MOVE_LEFT
    DEC ACTIVE[0]
    DEC ACTIVE[2]
    DEC ACTIVE[4]
    DEC ACTIVE[6]
    DEC AXISX
DONT_MOVE_LEFT:    
    POP DX
    POP CX
    POP AX
    
    CALL VALIDATE_STALL
    RET
MOVE_LEFT ENDP

VALIDATE_LEFT_MOVE PROC
    ; AL = 0 IF POSSIBLE, NONZERO OTHERWISE
    CALL COPY_ACTIVE_TO_PREDICT
    DEC PREDICT[0]
    DEC PREDICT[2]
    DEC PREDICT[4]
    DEC PREDICT[6]
    CALL CHECK_PREDICT 
    
    RET
VALIDATE_LEFT_MOVE ENDP


MOVE_RIGHT PROC
    PUSH AX
    PUSH CX
    PUSH DX
    
    CALL VALIDATE_RIGHT_MOVE
    CMP AL, 0
    JNE DONT_MOVE_RIGHT
    INC ACTIVE[0]
    INC ACTIVE[2]
    INC ACTIVE[4]
    INC ACTIVE[6]
    INC AXISX
DONT_MOVE_RIGHT:    
    POP DX
    POP CX
    POP AX
    
    CALL VALIDATE_STALL
    RET
MOVE_RIGHT ENDP

VALIDATE_RIGHT_MOVE PROC
    ; AL = 0 IF POSSIBLE, NONZERO OTHERWISE
    CALL COPY_ACTIVE_TO_PREDICT
    INC PREDICT[0]
    INC PREDICT[2]
    INC PREDICT[4]
    INC PREDICT[6]
    CALL CHECK_PREDICT 
    
    RET
VALIDATE_RIGHT_MOVE ENDP

MOVE_DOWN PROC
    PUSH AX
    PUSH CX
    PUSH DX
    
    CALL VALIDATE_DOWN_MOVE
    CMP AL, 0
    JNE REACH_DOWN
    INC ACTIVE[1]
    INC ACTIVE[3]
    INC ACTIVE[5]
    INC ACTIVE[7]
    INC AXISY
    JMP MOVE_DOWN_DONE
REACH_DOWN:
    CALL SET_PIECE
    CALL CHECK_TO_CLEAR
    CALL GENERATE_NEW_PIECE
    
MOVE_DOWN_DONE:        
    POP DX
    POP CX
    POP AX
    
    CALL VALIDATE_STALL
    RET
MOVE_DOWN ENDP

VALIDATE_DOWN_MOVE PROC
    ; AL = 0 IF POSSIBLE, NONZERO OTHERWISE
    CALL COPY_ACTIVE_TO_PREDICT
    INC PREDICT[1]
    INC PREDICT[3]
    INC PREDICT[5]
    INC PREDICT[7]
    CALL CHECK_PREDICT 
    
    RET
VALIDATE_DOWN_MOVE ENDP

STALL PROC
    PUSH AX
    PUSH CX
    PUSH DX
    PUSH BX
    
    
    CALL VALIDATE_STALL
    
    ;MOV BL, STALL_STEP
    ADD ACTIVE[1], CL
    ADD ACTIVE[3], CL
    ADD ACTIVE[5], CL
    ADD ACTIVE[7], CL
    ADD AXISY, CL
    
        
    CALL SET_PIECE
    CALL CHECK_TO_CLEAR
    CALL GENERATE_NEW_PIECE
    
    
    
    POP BX
    POP DX
    POP CX
    POP AX
    
    RET
STALL ENDP

VALIDATE_STALL PROC
    PUSH AX
    ; BL = NUMBER OF BLOCKS WHICH IT SHOULD MOVE DOWN
    CALL COPY_ACTIVE_TO_PREDICT
    MOV CL, 0
       
STALL_LOOP:        
    INC PREDICT[1]
    INC PREDICT[3]
    INC PREDICT[5]
    INC PREDICT[7]
    CALL CHECK_PREDICT
    CMP AL, 0
    JNE STALL_LOOP_END
    INC CL
    JMP STALL_LOOP
                 
STALL_LOOP_END:
    
    DEC PREDICT[1]
    DEC PREDICT[3]
    DEC PREDICT[5]
    DEC PREDICT[7]
     
    CALL DRAW_PREDICTION_PIECE
    POP AX                      
    RET
VALIDATE_STALL ENDP

ROTATE PROC
    PUSH AX
    CALL VALIDATE_ROTATE_MOVE
    CMP AL, 0
    JNE DONT_ROTATE
    MOV AL, PREDICT[0]
    MOV ACTIVE[0], AL
    
    MOV AL, PREDICT[1]
    MOV ACTIVE[1], AL
    
    MOV AL, PREDICT[2]
    MOV ACTIVE[2], AL
    
    MOV AL, PREDICT[3]
    MOV ACTIVE[3], AL
    
    MOV AL, PREDICT[4]
    MOV ACTIVE[4], AL
    
    MOV AL, PREDICT[5]
    MOV ACTIVE[5], AL
    
    MOV AL, PREDICT[6]
    MOV ACTIVE[6], AL
    
    MOV AL, PREDICT[7]
    MOV ACTIVE[7], AL
DONT_ROTATE:    
    POP AX
    
    CALL VALIDATE_STALL
    RET
ROTATE ENDP 
    
VALIDATE_ROTATE_MOVE PROC
    PUSH BX
    
    MOV BL, ACTIVE[0]
    MOV BH, ACTIVE[1]
    SUB BL, AXISX
    SUB BH, AXISY
    NEG BL
    ADD BL, AXISY
    ADD BH, AXISX
    MOV PREDICT[0], BH
    MOV PREDICT[1], BL
    
    MOV BL, ACTIVE[2]
    MOV BH, ACTIVE[3]
    SUB BL, AXISX
    SUB BH, AXISY
    NEG BL
    ADD BL, AXISY
    ADD BH, AXISX
    MOV PREDICT[2], BH
    MOV PREDICT[3], BL
    
    MOV BL, ACTIVE[4]
    MOV BH, ACTIVE[5]
    SUB BL, AXISX
    SUB BH, AXISY
    NEG BL
    ADD BL, AXISY
    ADD BH, AXISX
    MOV PREDICT[4], BH
    MOV PREDICT[5], BL
    
    MOV BL, ACTIVE[6]
    MOV BH, ACTIVE[7]
    SUB BL, AXISX
    SUB BH, AXISY
    NEG BL
    ADD BL, AXISY
    ADD BH, AXISX
    MOV PREDICT[6], BH
    MOV PREDICT[7], BL
    
    CALL CHECK_PREDICT
    
    POP BX
    
    RET
VALIDATE_ROTATE_MOVE ENDP

SET_PIECE PROC
    PUSH BX
    PUSH CX
    PUSH DX
    
    MOV CH, 0
    MOV DH, 0
    MOV DL, ACTIVE[7]
    SHL DX, 4
    MOV CL, ACTIVE[6]
    MOV BX, DX
    ADD BX, CX
    MOV CH, GRID_NON_BACKGROUND_COLOR
    CMP GRID[BX], CH
    MOV CH, 0
    JE SET_GAMEOVER
    MOV CH, ACTIVE_PIECE_COLOR
    MOV GRID[BX], CH
    MOV CH, 0
    
    MOV DH, 0
    MOV DL, ACTIVE[5]
    SHL DX, 4
    MOV CL, ACTIVE[4]
    MOV BX, DX
    ADD BX, CX
    MOV CH, GRID_NON_BACKGROUND_COLOR
    CMP GRID[BX], CH
    MOV CH, 0
    JE SET_GAMEOVER
    MOV CH, ACTIVE_PIECE_COLOR
    MOV GRID[BX], CH
    MOV CH, 0
    
    MOV DH, 0
    MOV DL, ACTIVE[3]
    SHL DX, 4
    MOV CL, ACTIVE[2]
    MOV BX, DX
    ADD BX, CX
    MOV CH, GRID_NON_BACKGROUND_COLOR
    CMP GRID[BX], CH
    MOV CH, 0
    JE SET_GAMEOVER
    MOV CH, ACTIVE_PIECE_COLOR
    MOV GRID[BX], CH
    MOV CH, 0
    
    MOV DH, 0
    MOV DL, ACTIVE[1]
    SHL DX, 4
    MOV CL, ACTIVE[0]
    MOV BX, DX
    ADD BX, CX
    MOV CH, GRID_NON_BACKGROUND_COLOR
    CMP GRID[BX], CH
    MOV CH, 0
    JE SET_GAMEOVER
    MOV CH, ACTIVE_PIECE_COLOR
    MOV GRID[BX], CH
    MOV CH, 0
    JMP SET_PIECE_DONE
SET_GAMEOVER:
    MOV GAME_OVER, 1
SET_PIECE_DONE:    
    POP DX
    POP CX
    POP BX
    
    RET
SET_PIECE ENDP

COPY_ACTIVE_TO_PREDICT PROC
    PUSH AX
    PUSH CX
    PUSH DX
    
    MOV BL, ACTIVE[0]
    MOV PREDICT[0], BL
    
    MOV BL, ACTIVE[1]
    MOV PREDICT[1], BL
    
    MOV BL, ACTIVE[2]
    MOV PREDICT[2], BL
    
    MOV BL, ACTIVE[3]
    MOV PREDICT[3], BL
    
    MOV BL, ACTIVE[4]
    MOV PREDICT[4], BL
    
    MOV BL, ACTIVE[5]
    MOV PREDICT[5], BL
    
    MOV BL, ACTIVE[6]
    MOV PREDICT[6], BL
    
    MOV BL, ACTIVE[7]
    MOV PREDICT[7], BL
    
    POP DX
    POP CX
    POP AX
    
    RET
COPY_ACTIVE_TO_PREDICT ENDP

CHECK_PREDICT PROC
    ; AL = 0 IF POSSIBLE, NONZERO OTHERWISE
    PUSH BX
    PUSH CX
    PUSH DX
    
    MOV CH, 0
    MOV DH, 0
    MOV DL, PREDICT[7]
    SHL DX, 4
    MOV CL, PREDICT[6]
    MOV BX, DX
    ADD BX, CX
    MOV CH, GRID_BACKGROUND_COLOR
    CMP GRID[BX], CH
    MOV CH, 0
    JNE MISSFIT
    
    MOV DH, 0
    MOV DL, PREDICT[5]
    SHL DX, 4
    MOV CL, PREDICT[4]
    MOV BX, DX
    ADD BX, CX
    MOV CH, GRID_BACKGROUND_COLOR
    CMP GRID[BX], CH
    MOV CH, 0
    JNE MISSFIT
    
    MOV DH, 0
    MOV DL, PREDICT[3]
    SHL DX, 4
    MOV CL, PREDICT[2]
    MOV BX, DX
    ADD BX, CX
    MOV CH, GRID_BACKGROUND_COLOR
    CMP GRID[BX], CH
    MOV CH, 0
    JNE MISSFIT
    
    MOV DH, 0
    MOV DL, PREDICT[1]
    SHL DX, 4
    MOV CL, PREDICT[0]
    MOV BX, DX
    ADD BX, CX
    MOV CH, GRID_BACKGROUND_COLOR
    CMP GRID[BX], CH
    MOV CH, 0
    JNE MISSFIT
    
    MOV AL, 0
    JMP CHECK_PREDICT_DONE
MISSFIT:     
    MOV AL, 1    
CHECK_PREDICT_DONE:       
    POP DX
    POP CX
    POP BX
            
    RET
CHECK_PREDICT ENDP

CHECK_TO_CLEAR PROC
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    
    MOV DL, 0
    MOV DH, 0
    MOV CL, 0
    PUSH CX
    
    MOV AL, ACTIVE[1]
    CMP AL, ACTIVE[3]
    JE CHECK_BLOCK1_DUP
    CMP AL, ACTIVE[5]
    JE CHECK_BLOCK1_DUP
    CMP AL, ACTIVE[7]
    JE CHECK_BLOCK1_DUP
    JMP CHECK_BLOCK1_NO_DUP
    
CHECK_BLOCK1_DUP:
    MOV AL, 0
    JMP CHECK_BLOCK1_DONE
CHECK_BLOCK1_NO_DUP:
    MOV CX, 16
    MOV BH, 0
    MOV BL, ACTIVE[1]
    SHL BX, 4
    MOV AL, 0
CHECK_BLOCK1_LOOP:
    
    CMP GRID[BX], 0
    JE CHECK_BLOCK1_DONE
    INC BX
    LOOP CHECK_BLOCK1_LOOP  ; ROW IS NOW READY TO BE CLEARED
    MOV AL, ACTIVE[1]
CHECK_BLOCK1_DONE:
    POP CX                
    MOV CL, AL

CHECK_BLOCK2:
    MOV CH, 0
    PUSH CX
    MOV AL, ACTIVE[3]
    CMP AL, ACTIVE[5]
    JE CHECK_BLOCK2_DUP
    CMP AL, ACTIVE[7]
    JE CHECK_BLOCK2_DUP
    JMP CHECK_BLOCK2_NO_DUP
CHECK_BLOCK2_DUP:
    MOV AL, 0
    JMP CHECK_BLOCK2_DONE
CHECK_BLOCK2_NO_DUP:
    MOV CX, 16
    MOV BH, 0
    MOV BL, ACTIVE[3]
    SHL BX, 4
    MOV AL, 0
CHECK_BLOCK2_LOOP:
    CMP GRID[BX], 0
    JE  CHECK_BLOCK2_DONE
    INC BX
    LOOP CHECK_BLOCK2_LOOP  ; ROW NOW IS READY TO BE CLEARED
    MOV AL, ACTIVE[3]
CHECK_BLOCK2_DONE:
    POP CX
    MOV CH, AL

CHECK_BLOCK3:
    PUSH CX
    MOV DL, 0
    MOV AL, ACTIVE[5]
    CMP AL, ACTIVE[7]
    JE CHECK_BLOCK3_DONE
    MOV CX, 16
    MOV BH, 0
    MOV BL, ACTIVE[5]
    SHL BX, 4
CHECK_BLOCK3_LOOP:
    CMP GRID[BX], 0
    JE CHECK_BLOCK3_DONE
    INC BX
    LOOP CHECK_BLOCK3_LOOP  ; ROW IS NOW READY TO BE CLEARED
    MOV DL, ACTIVE[5]
CHECK_BLOCK3_DONE:
    POP CX

CHECK_BLOCK4:
    PUSH CX
    MOV DH, 0
    MOV CX, 16
    MOV BH, 0
    MOV BL, ACTIVE[7]
    SHL BX, 4
CHECK_BLOCK4_LOOP:
    CMP GRID[BX], 0
    JE  CHECK_BLOCK4_DONE  ; ROW IS NOW READY TO BE CLEARED
    INC BX
    LOOP CHECK_BLOCK4_LOOP    
    MOV DH, ACTIVE[7]
CHECK_BLOCK4_DONE:
    POP CX
    CALL CLEAR_ROWS
    
    POP DX
    POP CX
    POP BX
    POP AX
    
    RET
CHECK_TO_CLEAR ENDP

CLEAR_ROWS PROC
    PUSH AX
    PUSH BX

    
    ; AL = COUNTER FOR CURRENT ROW INDEX
    ; AH = ROW DIFFERENCE
    MOV AL, 30
CLEAR_ROWS_FOR_EACH_ROW:
    MOV AH, 0
    CMP AL, CL
    JA CLEAR1_NO_INC
    MOV TO_CLEAR, 1
    
    INC AH
CLEAR1_NO_INC:
    CMP AL, CH
    JA CLEAR2_NO_INC
    MOV TO_CLEAR, 1
    
    INC AH
CLEAR2_NO_INC:
    CMP AL, DL
    JA CLEAR3_NO_INC
    MOV TO_CLEAR, 1
    
    INC AH
CLEAR3_NO_INC:
    CMP AL, DH
    JA CLEAR4_NO_INC
    MOV TO_CLEAR, 1
    
    INC AH
CLEAR4_NO_INC:
    PUSH CX
    PUSH DX
    MOV DH, 16
    MOV BH, 0
    MOV BL, AL
    SHL BX, 4
CLEAR_ROWS_FOR_EACH_ELEMENT_IN_ROW:
    MOV CH, 0
    MOV CL, AH
    SHL CX, 4
    SUB BX, CX
    MOV DL, GRID[BX]
    ADD BX, CX
    MOV GRID[BX], DL
    INC BX
    DEC DH
    CMP DH, 0
    JNE CLEAR_ROWS_FOR_EACH_ELEMENT_IN_ROW
    
    POP DX
    POP CX
    DEC AL
    CMP AL, 3
    JNE CLEAR_ROWS_FOR_EACH_ROW
    
    POP BX
    POP AX        
    
    CMP TO_CLEAR, 1
    JNE DONT_UPDATE_SCORE
    ADD SCORE, 10
    MOV TO_CLEAR, 0
    CALL DISPLAY_SCORE
    CALL DISPLAY_SCORE_ON_LED
    
DONT_UPDATE_SCORE:        
    
    RET
CLEAR_ROWS ENDP

CHECK_TIME PROC
    ; RETURN AL = 0 IF TICK, 1 FOR NO TICK
    PUSH CX
    PUSH DX
    
    MOV AH, 0
    INT 1AH
    CMP CX, TICKHI
    JB CHECK_TIME_NO_TICK
    CMP DX, TICKLO
    JB CHECK_TIME_NO_TICK
    ; TICK
    ADD DX, 10
    ; CARRY ??
    JNC CHECK_TIME_NO_CARRY
    INC CX
CHECK_TIME_NO_CARRY:
    MOV TICKHI, CX
    MOV TICKLO, DX
    MOV AL, 0
    JMP CHECK_TIME_DONE
CHECK_TIME_NO_TICK:
    MOV AL, 1
CHECK_TIME_DONE:          
    POP DX
    POP CX
    RET
CHECK_TIME ENDP

DISPLAY_SCORE PROC
    
    PUSH AX
    PUSH BX
    PUSH DX
    PUSH CX
    
    MOV AX, SCORE
    MOV DL, 100
    DIV DL
    MOV CL, '0'
    ADD CL, AL    
    MOV [MSG_SCORE+1], CL ; SET HUNDREDS DIGIT
    
    MOV AL, AH
    MOV AH, 0
    MOV DL, 10
    DIV DL
    MOV CL, '0'
    ADD CL, AL
    MOV [MSG_SCORE+2], CL   ; SET TENS DIGIT
                         
    MOV CL, '0'
    ADD CL, AH
    MOV [MSG_SCORE+3], CL   ; SET UNITS DIGIT
    
    MOV BX, OFFSET MSG_SCORE
    MOV DH, 17
    MOV DL, 33
    CALL PRINT_STRING_AT                                         
    
    POP CX
    POP DX
    POP BX
    POP AX
                                             
    RET
DISPLAY_SCORE ENDP

PRINT_STRING_AT PROC
    ; DH = ROW
    ; DL = COLUMN
    ; BX = ADDRESS OF STRING
    
    ; SET CURSOR'S POSITION
    PUSH BX
    
    MOV BH, 0    
    MOV AH, 2
    INT 10H
    
    ; OUTPUT STRING    
    MOV AH, 9
    POP DX
    INT 21H
        
    RET
PRINT_STRING_AT ENDP

PROC DISPLAY_SCORE_ON_LED
    PUSH AX
    
    MOV AX, SCORE
    OUT 199, AX 
    
    POP AX                                         
                                           
    RET
ENDP DISPLAY_SCORE_ON_LED